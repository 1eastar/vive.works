---
id: "20221212"
slug: "/20221212"
title: "개인 블로그를 만들다 (feat. Gatsby)"
description: "블로그를 만드는 여정, 그 과정에서 새로 배우고 느낀 점을 기록하고자 합니다"
author: "Vive Kang"
date: "2022-12-12"
image: ""
tags: ["Gatsby", "Web"]

---

개발을 시작한 지 얼마 안 되었을 때 개인 블로그를 제작한 적이 있다. 부족한 실력이지만 Django로 서버도 만들었고, CRA로 프론트도 만들고, docker를 이용해 배포까지 하면서 나름 고군분투했었다. 무슨 자신감이었는지 그 당시의 목표는 외부 패키지를 최대한 쓰지 않고 게시글 + 댓글 기능(심지어 에디터도 직접 만들려고 했었다)과 포트폴리오 겸 개인 프로젝트 정리하는 기능을 넣으려 했다. 지금 돌이켜보면 그 용기에 박수를 쳐주고 싶다. 당연히 제대로 완성하지 못했다. 어느정도 포트폴리오랑 게시판의 구색을 갖출 무렵 회사에 들어가게 되면서 점점 할애하는 시간이 적어졌고 그렇게 잊고 지내다가 어느 순간 서버를 내리게 되었다.

실패는 아니지만 성공적이라고도 볼 수 없는 그때의 기억때문인지, 그 후로도 계속 개인 블로그 제작에 대한 욕심을 갖고 있었는데 최근 gatsby에 대한 호기심과 맞물려 다시 한번 만들기로 마음 먹었다.

# 이번엔 디자인부터 제대로!
예전에는 디자인을 따로 생각하지 않고 내키는 대로 만들었다. 일단 코드를 작성하고 나서 화면에 보이는 디자인이 이상하면 그때그때 고치는 식으로 진행을 했었지만, 이번에는 figma를 이용해 디자인부터 시작했다. 더불어 dark/light theme 각각의 색상도 정하고 shade(100-900)도 정했다.

![vive works figma design](../statics/images/site_design.jpeg)

> 부족하긴 하지만 개인 프로젝트를 하는 수준에서는 이정도만 해도 충분하다고 생각했다.

그 효과는 굉장했다! 디자인을 하고 코드를 작성하는 것과 맨바닥에서 시작하는 건 진짜 천지차이라는 걸 직접 체감할 수 있었다. 작업 속도가 훨씬 빨라지는 건 당연하고 개발할 때는 개발만, 디자인할 때는 디자인만 집중해서 한가지만 한다는 게 엄청난 메리트라는 게 느껴졌다. 

# Gatsby
Gatsby를 한번도 사용해본 적이 없기에 공식 문서부터 쭉 훑기 시작했다. 공식 문서가 엄청 친절하다고 느꼈다. 필요할 법한 기능들에 대해서 어떤 패키지를 쓰는 게 좋고, 어떤 플러그인을 쓰는 게 좋고... 등 gatsby 측에서 권장하는 방식에 대해 다 기술해 놓았다. 예를 들어, 검색 기능에는 algoria search 를, 페이지 전체적인 layout 적용을 위해서는 gatsby-plugin-layout 이라는 플러그인을 추천한다. 물론 이런 점이 무조건 좋은 점이라 보기는 어렵지만 플러그인을 설치하기 전에 내부 코드부터 확인하던 내 입장에서, 수많은 플러그인 중에서 선택지를 좁혀주는 건 정말 마음에 들었다.

이렇게 순탄하지만은 않았는데, gatsby를 사용하기 위해서는 gatsby 자체가 내부에서 어떻게 돌아가는지 잘 알아야 했다. graphql 사용법도 어느정도 알아야 하고, gatsby 만의 page query 방식, gatsby-* 파일들 등 추가적으로 공부해야 할 게 꽤 있다는 느낌을 받았다. 

## SEO
이번 블로그는 SEO에 신경을 최대한 썼다. 신경을 쓴다고 했지만 애초에 정적 사이트로 빌드가 되는 gatsby 특성상 어려울 게 없었다. react-helmet을 이용해 페이지별로 다른 title, description, og 등을 설정해주고, sitemap, robots 설정을 해주었다.
그리고 네이버 서치어드바이저와 구글 서치 콘솔에 사이트 등록도 마쳤다. 

### HEAD API


## MDX
처음엔 `.md`로 세팅을 했다가 `.mdx`로 수정해주었다. tag들을 내가 직접 커스텀할 수 있다는 점이 마음에 들었고, 지금 세어보니 13개나 되는 tag를 커스터마이징했다. `@mdx-js/react` v1에서는 code, inlineCode를 구분해서 커스텀이 가능했는데, v2에서는 inlineCode가 deprecate 되었다. 그래서 결국 코드 블럭으로 사용하는 pre tag를 codeBlock으로 커스텀하여 사용하고 있다. code tag만 커스텀하여 사용하게 되면 결국 inlineCode와 codeBlock에 동일한 스타일이 적용되는데, 누가 이렇게 쓰려고 할지.... 어차피 대부분 나처럼 따로 커스텀해서 사용할텐데 왜 없앴는지 의문이 든다.

### AST 에러
```ts
// gatsby-node.ts
createPage<PageContext>({
  component: `${postTemplatePath.trim()}?__contentFilePath=${node.internal.contentFilePath}`,
  ...
})
```

`.md`에서 `.mdx`로 바꾸느라 `?_contentFilePath=${node.internal.contentFilePath}` 부분을 추가해주면서 에러가 발생했다.

> Invalid AST. Parsed source code did not 'return' valid outputInvalid AST.

처음에는 이것저것 검색을 통해 해결해려 했는데 레퍼런스가 너무 부족했고, 안 되겠다 싶어 이후엔 gatsby를 클론 받아서 오류 문구로부터 코드를 역추적했다.
```js
// gatsby-layout-loader.ts
const tree = acorn.Parser.extend(JSX()).parse(source, {
      ecmaVersion: 2020,
      sourceType: `module`,
      locations: true,
    })
```

acorn으로 파싱하는 부분에서 에러가 나는 게 확인되었다. `source`로 들어가는 내 코드가 문제라는 뜻인데, 나중에 원인을 파악했을 땐 정말 아차 싶었다. ts 트랜스파일을 안 해주고 있었던 게 문제였다... `@babel/preset-typescript`이나 `gatsby-plugin-typescript`를 추가해주니 무슨 일 있었냐는 듯 깔끔하게 해결되었다. 젠장.

{/* ### babel, tsc, webpack
## tree shaking
build time 10s 단축 */}

## pre commit
lint 체크, type 체크, 테스트 실행 이 3가지는 자동화를 시켜놓지 않으면 자주 깜빡하기도 하고 때로는 번거롭기도 해서 잘 안 하게 된다.(적어도 나한텐 그렇다.) 그래서 commit 할 때 이 3가지를 다 통과해야만 커밋이 되도록 git hook을 걸어 두었다. 처음에는 lint-staged와 pre-commit 이라는 패키지를 이용했다. 패키지 자체도 괜찮아보였고 어차피 여러가지 git hook들 중에 pre commit 만 사용할 거니까. 다만 사용하는 내내 찜찜했던 건 last published가 6년 전이라는 것. 분명 더 괜찮은 게 나왔을텐데 하는 마음으로 좀 찾아보니 husky라는 패키지가 있었다. pre-commit 패키지보다 훨씬 가벼우면서 모든 종류의 git hook을 지원하고 있었기에 교체를 안 할 이유가 없었다.

---

피드백은 언제나 환영입니다.
